import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { authenticateApiKey, logApiUsage } from '@/lib/api-middleware';
import { logger } from '@/lib/logger';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ userId: string }> }
) {
  const authResult = await authenticateApiKey(request);
  
  if ('error' in authResult) {
    return NextResponse.json({ error: authResult.error }, { status: authResult.status });
  }

  const { app } = authResult;
  const { userId } = await params;
  const { searchParams } = new URL(request.url);
  const campaignId = searchParams.get('campaignId');

  try {
    // Build base where clause scoped to app
    const baseWhere: any = {
      Campaign: {
        appId: app.id,
      },
    };

    if (campaignId) {
      baseWhere.Campaign.id = campaignId;
    }

    // Referrals made by this user (as referrer)
    const referralsMadeWhere = {
      ...baseWhere,
      referrerId: userId,
    };

    const [referralsMadeTotal, referralsMadeClicked, referralsMadeConverted, rewardsLegacyAgg] = await Promise.all([
      prisma.referral.count({ where: referralsMadeWhere }),
      prisma.referral.count({
        where: {
          ...referralsMadeWhere,
          status: { in: ['CLICKED', 'CONVERTED'] },
        },
      }),
      prisma.referral.count({
        where: {
          ...referralsMadeWhere,
          status: 'CONVERTED',
        },
      }),
      prisma.referral.aggregate({
        where: {
          ...referralsMadeWhere,
          status: 'CONVERTED',
        },
        _sum: { rewardAmount: true },
      }),
    ]);

    // Use Reward table for pending/paid when available; fallback to legacy (paid = converted sum, pending = 0) if Reward table missing or query fails
    let pendingAmount = 0;
    let paidAmount = 0;
    try {
      const rewardWhere = {
        userId,
        appId: app.id,
        ...(campaignId ? { Referral: { campaignId } } : {}),
      };
      const [rewardsPendingAgg, rewardsPaidAgg] = await Promise.all([
        prisma.reward.aggregate({
          where: {
            ...rewardWhere,
            status: { in: ['PENDING', 'APPROVED'] },
          },
          _sum: { amount: true },
        }),
        prisma.reward.aggregate({
          where: {
            ...rewardWhere,
            status: 'PAID',
          },
          _sum: { amount: true },
        }),
      ]);
      pendingAmount = rewardsPendingAgg._sum.amount ?? 0;
      paidAmount = rewardsPaidAgg._sum.amount ?? 0;
    } catch (_err) {
      // Reward table may not exist yet (migration not applied); use legacy: paid = sum of converted referral amounts, pending = 0
      paidAmount = rewardsLegacyAgg._sum.rewardAmount ?? 0;
      pendingAmount = 0;
    }

    // Referrals received by this user (as referee)
    const referralsReceivedWhere = {
      ...baseWhere,
      refereeId: userId,
    };

    const referralsReceived = await prisma.referral.findMany({
      where: referralsReceivedWhere,
      include: {
        Campaign: {
          select: {
            id: true,
            name: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
      take: 1, // Most recent referral received
    });

    // Referral codes generated by this user
    const referralCodesGenerated = await prisma.referral.findMany({
      where: referralsMadeWhere,
      include: {
        Campaign: {
          select: {
            id: true,
            name: true,
          },
        },
        Conversion: {
          select: {
            id: true,
            amount: true,
            createdAt: true,
          },
          orderBy: { createdAt: 'desc' },
          take: 1,
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    // Referral codes used by this user (when they were referred)
    const referralCodesUsed = await prisma.referral.findMany({
      where: referralsReceivedWhere,
      include: {
        Campaign: {
          select: {
            id: true,
            name: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    // Calculate clicks and conversions for each generated code
    const codesGeneratedWithStats = await Promise.all(
      referralCodesGenerated.map(async (ref) => {
        const clicks = await prisma.referral.count({
          where: {
            referralCode: ref.referralCode,
            status: { in: ['CLICKED', 'CONVERTED'] },
          },
        });
        const conversions = await prisma.referral.count({
          where: {
            referralCode: ref.referralCode,
            status: 'CONVERTED',
          },
        });
        return {
          referralCode: ref.referralCode,
          campaignId: ref.campaignId,
          campaignName: ref.Campaign.name,
          status: ref.status,
          createdAt: ref.createdAt,
          clicks,
          conversions,
          rewardAmount: ref.rewardAmount || 0,
        };
      })
    );

    const totalRewards = pendingAmount + paidAmount;

    await logApiUsage(app.id, `/api/v1/users/${userId}/stats`, request);

    await logger.info('User stats fetched', 'api.v1.users.stats', { appId: app.id, userId });

    return NextResponse.json({
      userId,
      referralsMade: {
        total: referralsMadeTotal,
        clicked: referralsMadeClicked,
        converted: referralsMadeConverted,
      },
      referralsReceived: referralsReceived.length > 0
        ? {
            total: referralsReceived.length,
            referrerId: referralsReceived[0].referrerId,
            referralCode: referralsReceived[0].referralCode,
            campaignId: referralsReceived[0].campaignId,
            campaignName: referralsReceived[0].Campaign.name,
            converted: referralsReceived[0].status === 'CONVERTED',
            receivedAt: referralsReceived[0].createdAt,
          }
        : null,
      rewardsEarned: {
        total: totalRewards,
        pending: pendingAmount,
        paid: paidAmount,
      },
      referralCodesGenerated: codesGeneratedWithStats,
      referralCodesUsed: referralCodesUsed.map((ref) => ({
        referralCode: ref.referralCode,
        referrerId: ref.referrerId,
        campaignId: ref.campaignId,
        campaignName: ref.Campaign.name,
        status: ref.status,
        usedAt: ref.createdAt,
        rewardEarned: ref.rewardAmount || 0,
      })),
    });
  } catch (error) {
    console.error('Error fetching user stats:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
